#include <queue>#include <iostream>#include <stdio.h>#include "ns3/core-module.h"#include "ns3/network-module.h"#include "ns3/internet-module.h"#include "ns3/applications-module.h"#include "ns3/mobility-module.h"#include "ns3/wifi-module.h"#include "ns3/aodv-module.h"#include "ns3/flow-monitor-module.h"#include "ns3/mobility-module.h"#include "myapp.h"#include "ns3/netanim-module.h"#include "ns3/propagation-loss-model.h"//#include "ns3/nakagami-propagation-loss-model.h"NS_LOG_COMPONENT_DEFINE ("makan");int main(int argc, char* argv[]) {	std::cout << "Program start" << std::endl;	std::string phyMode ("DsssRate1Mbps");	int width = 4;//pocet nodov	int numberOfNodes = width*width;	NS_LOG_INFO ("Create nodes.");	NodeContainer nodeContainer;	nodeContainer.Create(numberOfNodes);//vytvorenie poctu nodov	// Set up WiFi	WifiHelper wifi;	YansWifiPhyHelper wifiPhy =  YansWifiPhyHelper::Default ();	wifiPhy.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11);	// https://www.nsnam.org/doxygen/group__propagation.html	YansWifiChannelHelper wifiChannel;	wifiChannel.SetPropagationDelay ("ns3::RandomPropagationDelayModel"); // n·hodnÈ oneskorenia sign·lu//Ptr<NakagamiPropagationLossModel> nak = CreateObject<NakagamiPropagationLossModel>();//nak.Set("m0", DoubleValue (1.0));//nak.Set("m1", DoubleValue (1.0));//nak.Set("m2", DoubleValue (1.0));	wifiChannel.AddPropagationLoss ("ns3::NakagamiPropagationLossModel"); // TOTO ZMENIT//wifiChannel.AddPropagationLoss (nak); // TOTO ZMENIT	// For range near 250m	wifiPhy.Set ("TxPowerStart", DoubleValue(33));	wifiPhy.Set ("TxPowerEnd", DoubleValue(33));	wifiPhy.Set ("TxPowerLevels", UintegerValue(1));	wifiPhy.Set ("TxGain", DoubleValue(0));	wifiPhy.Set ("RxGain", DoubleValue(0));	wifiPhy.Set ("EnergyDetectionThreshold", DoubleValue(-61.8));	wifiPhy.Set ("CcaMode1Threshold", DoubleValue(-64.8));	wifiPhy.SetChannel (wifiChannel.Create ());		// Add a non-QoS upper mac	NqosWifiMacHelper wifiMac = NqosWifiMacHelper::Default ();	wifiMac.SetType ("ns3::AdhocWifiMac");	// https://www.nsnam.org/doxygen/wifi-phy-standard_8h_source.html	// 802.11g	wifi.SetStandard (WIFI_PHY_STANDARD_80211g);//	wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager", "DataMode",StringValue(phyMode), "ControlMode",StringValue(phyMode));	NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, nodeContainer);	// AODV	AodvHelper aodv;	Ipv4ListRoutingHelper list;	list.Add (aodv, 10);	// Set up internet stack	InternetStackHelper internet;	internet.SetRoutingHelper (list);	internet.Install (nodeContainer);	// Set up Addresses	Ipv4AddressHelper ipv4;	 NS_LOG_INFO ("Assign IP Addresses.");	ipv4.SetBase ("10.1.1.0", "255.255.255.0");	Ipv4InterfaceContainer ifcont = ipv4.Assign (devices);	NS_LOG_INFO ("Create Applications.");	uint16_t sinkPort = 6;		std::deque<int> d;	for (int i = 0; i < numberOfNodes; i++)		d.push_front(i);	std::random_shuffle(d.begin(), d.end());	std::queue<int> q(d);	int N1, N2, N4, N5, N6, N7, N8, N9, N10, N11;	N1 = q.front();q.pop();	N2 = q.front();q.pop();	N4 = q.front();q.pop();	N5 = q.front();q.pop();	N6 = q.front();q.pop();	N7 = q.front();q.pop();	N8 = q.front();q.pop();	N9 = q.front();q.pop();	N10 = q.front();q.pop();	N11 = q.front();q.pop();	std::cout << "Creating application layer" << std::endl;	// aplikaËn˙ vrstvu naprogramujte tak, aby dva uzly posielali 10MB bajtov po max. (XXX):	uint32_t packetSize = 1024; // B	uint32_t nPackets =  3000; // 10MB		// n·hodne vybranÈ uzoly N1 a N2 ( N1 != N2 ) zaËali komunikovaù v Ëase, 10s.	std::cout << "Sending from N" << (N1+1) << " to N" << (N2+1) << std::endl;	Address sinkAddress (InetSocketAddress (ifcont.GetAddress(N2), sinkPort));	PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));	ApplicationContainer sinkApps = packetSinkHelper.Install (nodeContainer.Get (N2));	sinkApps.Start (Seconds (9.));	sinkApps.Stop (Seconds (100.));	Ptr<Socket> ns3UdpSocket = Socket::CreateSocket (nodeContainer.Get (N1), UdpSocketFactory::GetTypeId ());	Ptr<MyApp> app = CreateObject<MyApp> ();	app->Setup (ns3UdpSocket, sinkAddress, packetSize, nPackets, DataRate ("250Kbps"));	nodeContainer.Get (N1)->AddApplication (app);	app->SetStartTime (Seconds (10.));	app->SetStopTime (Seconds (100.));	// n·hodne vybranÈ uzoly N4 a N5 ( N4 != N5 ) zaËali komunikovaù v Ëase, 12s.	std::cout << "Sending from N" << (N4+1) << " to N" << (N5+1) << std::endl;	Address sinkAddress2 (InetSocketAddress (ifcont.GetAddress(N5), sinkPort));	PacketSinkHelper packetSinkHelper2 ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));	ApplicationContainer sinkApps2 = packetSinkHelper2.Install (nodeContainer.Get (N5));	sinkApps2.Start (Seconds (11.));	sinkApps2.Stop (Seconds (100.));	Ptr<Socket> ns3UdpSocket2 = Socket::CreateSocket (nodeContainer.Get (N4), UdpSocketFactory::GetTypeId ());	Ptr<MyApp> app2 = CreateObject<MyApp> ();	app2->Setup (ns3UdpSocket2, sinkAddress2, packetSize, nPackets, DataRate ("250Kbps"));	nodeContainer.Get (N4)->AddApplication (app2);	app2->SetStartTime (Seconds (12.));	app2->SetStopTime (Seconds (100.));	// n·hodne vybranÈ uzoly N6 a N7 ( N6 != N7 ) zaËali komunikovaù v Ëase, 15s.	std::cout << "Sending from N" << (N6+1) << " to N" << (N7+1) << std::endl;	Address sinkAddress3 (InetSocketAddress (ifcont.GetAddress(N7), sinkPort));	PacketSinkHelper packetSinkHelper3 ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));	ApplicationContainer sinkApps3 = packetSinkHelper3.Install (nodeContainer.Get (N7));	sinkApps3.Start (Seconds (9.));	sinkApps3.Stop (Seconds (100.));	Ptr<Socket> ns3UdpSocket3 = Socket::CreateSocket (nodeContainer.Get (N6), UdpSocketFactory::GetTypeId ());	Ptr<MyApp> app3 = CreateObject<MyApp> ();	app3->Setup (ns3UdpSocket3, sinkAddress3, packetSize, nPackets, DataRate ("250Kbps"));	nodeContainer.Get (N6)->AddApplication (app3);	app3->SetStartTime (Seconds (10.));	app3->SetStopTime (Seconds (100.));	// n·hodne vybranÈ uzoly N8 a N9 ( N8 != N9 ) zaËali komunikovaù v Ëase, 16s.	std::cout << "Sending from N" << (N8+1) << " to N" << (N9+1) << std::endl;	Address sinkAddress4 (InetSocketAddress (ifcont.GetAddress(N9), sinkPort));	PacketSinkHelper packetSinkHelper4 ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));	ApplicationContainer sinkApps4 = packetSinkHelper4.Install (nodeContainer.Get (N9));	sinkApps4.Start (Seconds (15.));	sinkApps4.Stop (Seconds (100.));	Ptr<Socket> ns3UdpSocket4 = Socket::CreateSocket (nodeContainer.Get (N8), UdpSocketFactory::GetTypeId ());	Ptr<MyApp> app4 = CreateObject<MyApp> ();	app4->Setup (ns3UdpSocket4, sinkAddress4, packetSize, nPackets, DataRate ("250Kbps"));	nodeContainer.Get (N8)->AddApplication (app4);	app4->SetStartTime (Seconds (16.));	app4->SetStopTime (Seconds (100.));	// n·hodne vybranÈ uzoly N10 a N11 ( N10 != N11 ) zaËali komunikovaù v Ëase, 21s.	std::cout << "Sending from N" << (N10+1) << " to N" << (N11+1) << std::endl;	Address sinkAddress5 (InetSocketAddress (ifcont.GetAddress(N11), sinkPort));	PacketSinkHelper packetSinkHelper5 ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));	ApplicationContainer sinkApps5 = packetSinkHelper5.Install (nodeContainer.Get (N11));	sinkApps5.Start (Seconds (20.));	sinkApps5.Stop (Seconds (100.));	Ptr<Socket> ns3UdpSocket5 = Socket::CreateSocket (nodeContainer.Get (N10), UdpSocketFactory::GetTypeId ());	Ptr<MyApp> app5 = CreateObject<MyApp> ();	app5->Setup (ns3UdpSocket5, sinkAddress5, packetSize, nPackets, DataRate ("250Kbps"));	nodeContainer.Get (N10)->AddApplication (app5);	app5->SetStartTime (Seconds (21.));	app5->SetStopTime (Seconds (100.));		std::cout << "Creating mobility" << std::endl;	// Set Mobility for all nodes	MobilityHelper mobility;	mobility.SetPositionAllocator ("ns3::RandomRectanglePositionAllocator",                                 "X", StringValue ("ns3::UniformRandomVariable[Min=0|Max=500]"),                                 "Y", StringValue ("ns3::UniformRandomVariable[Min=0|Max=500]"));	mobility.SetMobilityModel("ns3::RandomWalk2dMobilityModel", "Bounds", RectangleValue (Rectangle (-1, 1001, -1, 1001)), "Distance", DoubleValue(20.0)); //n·hodn˝ pohyb po ceste s n·hodne meniacou sa r˝chlosùou	mobility.Install(nodeContainer);	std::cout << "Simulation stop" << std::endl;	Simulator::Stop (Seconds(100.0));	std::cout << "Creating visualization" << std::endl;	// dopÌöte do programu kÛd pre grafick˙ vizualiz·ciu siete pre program "NetAnim"	AnimationInterface anim ("mazari.xml"); // Mandatory	for (uint32_t i = 0; i < nodeContainer.GetN(); ++i){		std::ostringstream stringStream;		stringStream << "N" << i;		anim.UpdateNodeDescription (nodeContainer.Get (i), stringStream.str()); // Optional		anim.UpdateNodeColor (nodeContainer.Get (i), 255, 0, 0); // Optional	}	anim.EnablePacketMetadata (); // Optional	anim.EnableIpv4RouteTracking ("routingtable-wireless.xml", Seconds (0), Seconds (5), Seconds (0.25)); //Optional	anim.EnableWifiMacCounters (Seconds (0), Seconds (10)); //Optional	anim.EnableWifiPhyCounters (Seconds (0), Seconds (10)); //Optional	// Trace Received Packets	//Config::ConnectWithoutContext("/NodeList/*/ApplicationList/*/$ns3::PacketSink/Rx", MakeCallback (&ReceivePacket));	// Trace devices (pcap)	wifiPhy.EnablePcap ("makan-dev", devices);	NS_LOG_INFO ("Run Simulation.");	FlowMonitorHelper flowmon; Ptr<FlowMonitor> monitor = flowmon.InstallAll (); std::cout << "Simulation stop" << std::endl; Simulator::Stop (Seconds(100.0)); std::cout << "Simulation run" << std::endl; Simulator::Run (); std::cout << "Flow monitor setup" << std::endl; //stats of packet flow monitor->CheckForLostPackets (); Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier()); std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats(); std::cout << stats.size() << std::endl;	monitor->SerializeToXmlFile("makan.flowmon", true, true);	std::cout << "Simulation destroy" << std::endl;	Simulator::Destroy ();	std::cout << "End" << std::endl;	return 0;}/*- dopÌöte do programu kÛd pre vykreslenie grafu z·vislosti (vyuûite kniûnicu "gnuplot")-- parametra stratovosù poËtu bodov v sieti (YYY). (4b) spolu so ötandardnou odchylkou (2b)-- parametra oneskorenie poËtu bodov v sieti (YYY)). (4b) spolu so ötandardnou odchylkou.-- priemern˝ poËet poslan˝ch uûitoËn˝ch ˙dajov k celkovÈmu poËtu poslan˝ch ˙dajov na jednu cestu v z·vislosti veækosti balÌka (XXX) (4b) spolu so ötandardnou odchylkou (2b).*/